# RPCByHand

###   框架概述

该框架包括一下组件：

* **通信层**：负责处理网络通信，实现请求的传输和相应的接收。选择使用TCP协议进行通信，使用Netty作为网络库
* **序列化层**：负责将请求和相应进行序列化和反序列化，时期在网路传输中进行编码和解码。提供了支持常见序列化方式（jdk、JSON、hessian）的插件机制，同时也支持自定义序列化方式
* **服务注册与发现层**：负责服务的注册和发现，使客户端可以通过服务名称来发现可用的服务结点。使用一个中心话的服务注册中心来管理服务的注册和发现。
* **负载均衡层**：负责将请求合理地分配给服务结点，实现负载均衡。如最小相应、一致性hash、轮询
* **远程代理**：在客户端和服务端实现远程代理，封装远程调用的细节，是开发者可以向本地调用一样调用远程服务

###   架构设计

采用客户端---服务端架构

####   客户端架构

客户端架构包括以下组件：

* 远程代理：根据用户定义的接口，生成代理对象，封装远程调用的细节，将本地方法调用转化为远程调用
* 序列化器：将请求和相应进行序列化和反序列化，时期能够在网路中进行传输。（提供可配置的插件机制，支持多种序列化方式）
* 负载均衡器：根据负载均衡策略选择合适的服务街店，将请求发送给服务结点
* 通信模块：使用tcp协议进行网络通信，接受服务结点的相应

####  服务端架构

服务端架构包括以下组件：

* 远程调用处理器：接收来自客户端的请求，根据请求的就扣和方法调用相应的服务实现代码，并将结果返回给客户端
* 序列化器：将请求和相应进行序列化和反序列化，时期能够在网络总进行传输
* 通信模块：使用tcp协议进行网络通信，接受客户端的请求，并发送服务结点的相应

#### 注册中心架构

注册中心是中心化的服务注册与发思安的管理结点，服务记录和管理可用的服务结点信息，包括服务名称、地址、权重等。客户端和服务端都可以通过注册中心来发现和注册服务。

### 工作流程

1. 客户端通过远程代理对象调用远程服务
2. 远程代理将方法调用转化为rpc请求，使用负载均衡策略选择服务结点，并将请求发送给服务结点
3. 服务结点接收到请求后，使用序列化器队请求进行反序列化，找到对应的服务实现代码，并调用相应的方法
4. 服务实现完成后，将结果返回给服务结点
5. 服务结点使用序列化器对结果进行序列化，并将结果发送给客户啊短
6. 客户端接收到响应后，使用序列化器对相应进行发序列化，并将结果返回给用户

###   扩展性和可靠性

关键设计和决策：

* 插件机制：**使用插件机制来支持多种序列化方式和负载均衡策略**。开发者可以根据字节的需求实现自定义插件，来支持其他的序列化方式或负载均衡策略
* 服务注册中心：使用中心化的服务祖册中心来管理服务端额注册和发现，提供可靠的服务结点信息。注册中心可以实现高可用以确保系统的可靠性和稳定性
* 异常处理：该框架回对**网络异常、超时等情况进行处理，提供合适的错误信息和异常处理机制，以保证框架的可靠性**
* 日志和监控：框架会记录关键的日志信息，方便开发者定位和解决问题，此外也提供监控和性能统计功能，供开发者进行系统性能分析和优化


**目前完成 ：**

1、 使用netty框架进行基础的网络通信，实现**自定义协议**，封装请求和响应。

2、 独立完成了负载均衡的代码实现，实现了**轮询、一致性hash、最短响应时间**等几种常见的负载均衡策略，并且使用**模板方法模式**封装了负载均衡的骨架代码，子类独立实现负载均衡算法。

3、 实现了简易版的**限流器和熔断器**，分别用来保护服务调用方和提供方。

4、 通过业务分组实现了**流量隔离**，避免辅助型业务干扰核心业务，也可以做到不同核心业务的互相隔离。

5、 使用**工厂模式对外提供了多种序列化工具和压缩工具**，让代码的扩展性更高，同时通过spi+xml配置+代码配置的形式让整个工程**扩展性更强，更加灵活**。

**下一步计划（进行中）：**

1、 编写基于springboot的starter启动器，完成和springboot的融合。

2、针对netty+hessian的配置方式，对其做基准测试，对其进行性能分析。
